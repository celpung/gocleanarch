package test

import (
	"testing"

	repository_impl "github.com/celpung/gocleanarch/application/user/impl/repository"
	"github.com/celpung/gocleanarch/infrastructure/db/model" // Lightweight SQLite driver suitable for tests.
	"github.com/stretchr/testify/require"                    // Assertion helpers for clearer tests.
	"gorm.io/gorm"
)

/*
===============================================================================
Test Execution Guide (Windows / macOS / Linux)

1) Install dependencies at the project root:
     go get github.com/glebarez/sqlite gorm.io/gorm github.com/stretchr/testify
     go mod tidy

2) Run all tests in this package from the folder containing this file:
     go test -v .

3) Run a specific test using a regex:
     go test -v -run ^TestCreateUser$ .
     go test -v -run ^TestReadByIDUser$ .
     go test -v -run 'Test(ReadByEmailUser|ReadByEmailForLogin)$' .

4) Run the entire repository test suite from the project root:
     go test -v ./...

5) Coverage and race detection (optional):
     go test -race -cover .
     go test -coverprofile=cover.out . && go tool cover -html=cover.out

Notes:
- The User model should include gorm.DeletedAt to properly exercise soft delete paths.
- For string or UUID primary keys, repository queries by ID must use a predicate
  such as "id = ?" to avoid dialect-specific SQL parsing errors.
- In-memory SQLite uses ":memory:". If shared state across multiple connections
  is required, consider "file::memory:?cache=shared".
- If the database auto-generates UUIDs, leave the ID empty when creating records.
  Otherwise, set it manually in tests.
===============================================================================
*/

/*
setupTestDB creates an isolated in-memory SQLite database and migrates the
schema required by the tests. Each test should call this to ensure a clean,
independent state.
*/
// func setupTestDB(t *testing.T) *gorm.DB {
// 	t.Helper()

// 	db, err := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{})
// 	require.NoError(t, err, "failed to open in-memory SQLite database")

// 	/* Ensure the schema exists for all tests. The model should include DeletedAt so that soft deletes are correctly handled by GORM. */
// 	require.NoError(t, db.AutoMigrate(&model.User{}), "failed to auto-migrate schema")

// 	return db
// }

// makeUser constructs a minimal valid user model instance for test scenarios.
// For production flows, password hashing should occur in the use case layer.
func makeUser(name, email string) *model.User {
	return &model.User{
		// ID: uuid.NewString(), // Uncomment if IDs are not auto-generated by the DB.
		Name:     name,
		Email:    email,
		Password: "password123",
		Active:   true,
		Role:     1,
	}
}

/*
TestCreateUser verifies that a user can be persisted and an identifier is set upon creation.
*/
func TestCreateUser(t *testing.T) {
	db := setupTestDB(t)
	repo := repository_impl.NewUserRepository(db)

	u := makeUser("Alice", "alice@example.com")

	saved, err := repo.Create(u)
	require.NoError(t, err, "unexpected error during create")
	require.NotEmpty(t, saved.ID, "expected generated ID to be non-empty")
	require.Equal(t, "Alice", saved.Name)
	require.Equal(t, "alice@example.com", saved.Email)
}

/*
TestReadAllUsers verifies that multiple persisted users can be retrieved.
The repository does not enforce ordering; assertions should therefore avoid relying on a specific order.
*/
func TestReadAllUsers(t *testing.T) {
	db := setupTestDB(t)
	repo := repository_impl.NewUserRepository(db)

	_, err := repo.Create(makeUser("Maria", "maria@example.com"))
	require.NoError(t, err)
	_, err = repo.Create(makeUser("Bob", "bob@example.com"))
	require.NoError(t, err)

	users, total, err := repo.Read(1, 10)
	require.NoError(t, err, "unexpected error during read")
	require.Equal(t, int64(2), total, "total count harus 2")
	require.Len(t, users, 2, "expected exactly two users")

	// Validasi presence tanpa bergantung urutan.
	got := map[string]bool{}
	for _, u := range users {
		got[u.Name] = true
	}
	require.True(t, got["Maria"])
	require.True(t, got["Bob"])
}

/*
TestReadByIDUser verifies that a record can be retrieved by its identifier.
Repository implementation should use a predicate "id = ?" for string or UUID primary keys to avoid SQL parsing errors.
*/
func TestReadByIDUser(t *testing.T) {
	db := setupTestDB(t)
	repo := repository_impl.NewUserRepository(db)

	saved, err := repo.Create(makeUser("Charlie", "charlie@example.com"))
	require.NoError(t, err)

	got, err := repo.ReadByID(saved.ID)
	require.NoError(t, err, "unexpected error reading by ID")
	require.Equal(t, saved.ID, got.ID)
	require.Equal(t, "Charlie", got.Name)
}

/*
TestReadByEmailUser verifies projected reads by email and expects sensitive
fields to be omitted when the repository uses a public projection.
*/
func TestReadByEmailUser(t *testing.T) {
	db := setupTestDB(t)
	repo := repository_impl.NewUserRepository(db)

	saved, err := repo.Create(makeUser("Richard", "richard@example.com"))
	require.NoError(t, err)

	got, err := repo.ReadByEmailPublic("richard@example.com")
	require.NoError(t, err, "unexpected error reading by email")
	require.Equal(t, saved.Email, got.Email)

	require.Empty(t, got.Password, "password should not be returned by projected read")
}

/*
TestReadByEmailForLogin verifies that the authentication variant returns
the fields necessary for credential verification, such as the password hash.
*/
func TestReadByEmailForLogin(t *testing.T) {
	db := setupTestDB(t)
	repo := repository_impl.NewUserRepository(db)

	saved, err := repo.Create(makeUser("Diana", "diana@example.com"))
	require.NoError(t, err)

	got, err := repo.ReadByEmailPrivate("diana@example.com")
	require.NoError(t, err, "unexpected error reading for login")
	require.Equal(t, saved.Email, got.Email)
	require.Equal(t, "password123", got.Password, "login read should include password field")
}

/*
TestUpdateUser_StructUpdates verifies updates using struct-based Updates.
Note that Updates(struct) does not write zero values; use UpdateFields(map) when zero values must be persisted.
*/
func TestUpdateUser_StructUpdates(t *testing.T) {
	db := setupTestDB(t)
	repo := repository_impl.NewUserRepository(db)

	saved, err := repo.Create(makeUser("Eve", "eve@example.com"))
	require.NoError(t, err)

	saved.Name = "Eve Updated"
	saved.Email = "eve2@example.com"

	updated, err := repo.Update(saved)
	require.NoError(t, err, "unexpected error during update")
	require.Equal(t, "Eve Updated", updated.Name)
	require.Equal(t, "eve2@example.com", updated.Email)

	// Confirm via a fresh read using the repository projection.
	got, err := repo.ReadByID(saved.ID)
	require.NoError(t, err)
	require.Equal(t, "Eve Updated", got.Name)
	require.Equal(t, "eve2@example.com", got.Email)
}

/*
TestUpdateFields_AllowsZeroValues verifies that map-based Updates can persist
zero values, which is necessary for accurate partial updates.
*/
func TestUpdateFields_AllowsZeroValues(t *testing.T) {
	db := setupTestDB(t)
	repo := repository_impl.NewUserRepository(db)

	saved, err := repo.Create(makeUser("Frank", "frank@example.com"))
	require.NoError(t, err)

	updated, err := repo.UpdateFields(saved.ID, map[string]interface{}{
		"active": false,   // Zero-value boolean should be persisted.
		"role":   uint(0), // Zero-value integer should be persisted.
		"name":   "Frank Zeroed",
	})
	require.NoError(t, err, "unexpected error during map-based update")
	require.Equal(t, "Frank Zeroed", updated.Name)

	got, err := repo.ReadByID(saved.ID)
	require.NoError(t, err)
	require.False(t, got.Active, "expected active to be false after update")
	require.EqualValues(t, 0, got.Role, "expected role to be zero after update")
	require.Equal(t, "Frank Zeroed", got.Name)
}

/*
TestSoftDeleteUser verifies that a soft-deleted record is no longer returned
by default queries and does not appear in subsequent listings.
*/
func TestSoftDeleteUser(t *testing.T) {
	db := setupTestDB(t)
	repo := repository_impl.NewUserRepository(db)

	saved, err := repo.Create(makeUser("Gina", "gina@example.com"))
	require.NoError(t, err)

	// Soft delete
	err = repo.SoftDelete(saved.ID)
	require.NoError(t, err, "unexpected error during soft delete")

	// ReadByID harus ErrRecordNotFound (gunakan ErrorIs karena GORM bisa wrap error)
	_, err = repo.ReadByID(saved.ID)
	require.Error(t, err, "expected read by ID to fail after soft delete")
	require.ErrorIs(t, err, gorm.ErrRecordNotFound, "expected ErrRecordNotFound after soft delete")

	// Listing harus tidak menyertakan row yang terhapus
	users, total, err := repo.Read(1, 10)
	require.NoError(t, err, "unexpected error reading all users after soft delete")
	for _, us := range users {
		require.NotEqual(t, saved.ID, us.ID, "soft-deleted user must not be listed")
	}
	// Karena hanya 1 user awalnya, total seharusnya 0.
	require.Equal(t, int64(0), total, "total should exclude soft-deleted rows")
}
